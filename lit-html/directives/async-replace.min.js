var __asyncValues=this&&this.__asyncValues||function(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,r=e[Symbol.asyncIterator];return r?r.call(e):(e="function"==typeof __values?__values(e):e[Symbol.iterator](),t={},n("next"),n("throw"),n("return"),t[Symbol.asyncIterator]=function(){return this},t);function n(r){t[r]=e[r]&&function(t){return new Promise(function(n,a){!function(e,t,r,n){Promise.resolve(n).then(function(t){e({value:t,done:r})},t)}(n,a,(t=e[r](t)).done,t.value)})}}};import{directive,NodePart}from"../lit-html.js";export const asyncReplace=directive((e,t)=>async r=>{var n,a;if(!(r instanceof NodePart))throw Error("asyncReplace can only be used in text bindings");if(e===r.value)return;const o=new NodePart(r.options);r.value=e;let i=0;try{for(var l,c=__asyncValues(e);!(l=await c.next()).done;){let n=l.value;if(r.value!==e)break;0===i&&(r.clear(),o.appendIntoPart(r)),void 0!==t&&(n=t(n,i)),o.setValue(n),o.commit(),i++}}catch(e){n={error:e}}finally{try{l&&!l.done&&(a=c.return)&&await a.call(c)}finally{if(n)throw n.error}}});